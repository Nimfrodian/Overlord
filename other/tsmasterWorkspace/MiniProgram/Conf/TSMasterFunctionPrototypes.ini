[]
=void log(const char* format, ...);
=void printf(char* format, ...);
=void test_log(const char* format, ...);
=void test_log_ok(const char* format, ...);
=void test_log_nok(const char* format, ...);
=void test_logCAN(const char* ADesc, PCAN ACAN, const TLogLevel ALevel);

[var]
=Vtype get(void);
=void set(const Vtype AValue);

[timer]
=void start(void);
=void stop(void);
=void set_interval(const s32 AInterval);
=s32 get_interval(void);

[app]
=s32 set_current_application(const char* AAppName);
=s32 del_application(const char* AAppName);
=s32 add_application(const char* AAppName);
=s32 get_application_list(char** AAppNameList);
=s32 set_can_channel_count(const s32 ACount);
=s32 set_lin_channel_count(const s32 ACount);
=s32 get_can_channel_count(const ps32 ACount);
=s32 get_lin_channel_count(const ps32 ACount);
=s32 set_mapping(const PLIBTSMapping AMapping);
=s32 get_mapping(const PLIBTSMapping AMapping);
=s32 del_mapping(const PLIBTSMapping AMapping);
=s32 connect(void);
=s32 disconnect(void);
=void log(const char* AStr, const TLogLevel ALevel);
=s32 set_turbo_mode(const char* AAppName, const bool AEnable);
=s32 get_turbo_mode(const char* AAppName, const bool* AEnable);
=s32 get_error_description(const s32 ACode, char** ADesc);
=s32 configure_can_baudrate(const s32 AIdxChn, const float ABaudrateKbps, const bool AListenOnly, const bool AInstallTermResistor120Ohm);
=s32 configure_canfd_baudrate(const s32 AIdxChn, const float ABaudrateArbKbps, const float ABaudrateDataKbps, const TCANFDControllerType AControllerType, const TCANFDControllerMode AControllerMode, const bool AInstallTermResistor120Ohm);
=s32 terminate_application(void);
=void wait(const s32 ATimeMs, const char* AMsg);
=s32 check(const s32 AErrorCode);
=s32 start_log(void);
=s32 end_log(void);
=s32 check_terminate(void);
=s32 get_timestamp(s64* ATimestamp);
=s32 show_confirm_dialog(const char* ATitle, const char* APrompt, const char* AImage, const s32 ATimeoutMs, const bool ADefaultOK);
=s32 pause(void);
=s32 set_check_failed_terminate(const bool AToTerminate);
=s32 get_system_var_count(s32* AInternalCount, s32* AUserCount);
=s32 get_system_var_def_by_index(const bool AIsUser, const s32 AIndex, const PLIBSystemVarDef AVarDef);
=s32 get_system_var_def_by_name(const bool AIsUser, const char* ACompleteName, const PLIBSystemVarDef AVarDef);
=s32 get_system_var_double(const char* ACompleteName, double* AValue);
=s32 get_system_var_int32(const char* ACompleteName, s32* AValue);
=s32 get_system_var_uint32(const char* ACompleteName, u32* AValue);
=s32 get_system_var_int64(const char* ACompleteName, s64* AValue);
=s32 get_system_var_uint64(const char* ACompleteName, u64* AValue);
=s32 get_system_var_uint8_array(const char* ACompleteName, const s32 ACapacity, s32* AVarCount, u8* AValue);
=s32 get_system_var_int32_array(const char* ACompleteName, const s32 ACapacity, s32* AVarCount, s32* AValue);
=s32 get_system_var_int64_array(const char* ACompleteName, const s32 ACapacity, s32* AVarCount, s64* AValue);
=s32 get_system_var_double_array(const char* ACompleteName, const s32 ACapacity, s32* AVarCount, double* AValue);
=s32 get_system_var_string(const char* ACompleteName, const s32 ACapacity, char* AString);
=s32 set_system_var_double(const char* ACompleteName, double AValue);
=s32 set_system_var_int32(const char* ACompleteName, s32 AValue);
=s32 set_system_var_uint32(const char* ACompleteName, u32 AValue);
=s32 set_system_var_int64(const char* ACompleteName, s64 AValue);
=s32 set_system_var_uint64(const char* ACompleteName, u64 AValue);
=s32 set_system_var_uint8_array(const char* ACompleteName, const s32 ACapacity, u8* AValue);
=s32 set_system_var_int32_array(const char* ACompleteName, const s32 ACapacity, s32* AValue);
=s32 set_system_var_int64_array(const char* ACompleteName, const s32 ACapacity, s64* AValue);
=s32 set_system_var_double_array(const char* ACompleteName, const s32 ACapacity, double* AValue);
=s32 set_system_var_string(const char* ACompleteName, char* AString);
=s32 make_toast(const char* AString, const TLogLevel ALevel);
=s32 execute_python_string(const char* AString, const char* AArguments, const bool AIsSync, const bool AIsX64, char** AResultLog);
=s32 execute_python_script(const char* AFilePath, const char* AArguments, const bool AIsSync, const bool AIsX64, char** AResultLog);
=s32 execute_app(const char* AAppPath,  const char* AWorkingDir, const char* AParameter, const s32 AWaitTimeMS);
=s32 terminate_app_by_name(const char* AImageName);
=s32 excel_load(const char* AFileName, const void** AObj);
=s32 excel_get_sheet_count(const void* AObj, const s32* ACount);
=s32 excel_set_sheet_count(const void* AObj, const s32 ACount);
=s32 excel_get_sheet_name(const void* AObj, const s32 AIdxSheet, const char** AName);
=s32 excel_set_sheet_name(const void* AObj, const s32 AIdxSheet, const char* AName);
=s32 excel_get_cell_count(const void* AObj, const s32 AIdxSheet, const s32* ARowCount, const s32* AColCount);
=s32 excel_get_cell_value(const void* AObj, const s32 AIdxSheet, const s32 AIdxRow, const s32* AIdxCol, const char** AValue);
=s32 excel_set_cell_count(const void* AObj, const s32 AIdxSheet, const s32 ARowCount, const s32 AColCount);
=s32 excel_set_cell_value(const void* AObj, const s32 AIdxSheet, const s32 AIdxRow, const s32 AIdxCol, const char* AValue);
=s32 excel_unload(const void* AObj);
=s32 excel_unload_all(void);
=s32 log_system_var(const char* ACompleteName);
=s32 call_mini_program_api(const char* ALibName, const char* AFuncName, const char* AInParameters, char** AOutParameters);
=s32 split_string(const char* ASplitter, const char* AStr, const char** AArray, const s32 ASingleStrSize, const s32 AArraySize, s32* AActualCount);
=s32 wait_system_var_existance(const char* ACompleteName, const s32 ATimeOutMs);
=s32 wait_system_var_disappear(const char* ACompleteName, const s32 ATimeOutMs);
=s32 set_analysis_time_range(const s64 ATimeStartUs, const s64 ATimeEndUs);
=s32 get_configuration_file_name(char** AFileName);
=s32 get_configuration_file_path(char** AFilePath);
=s32 set_default_output_dir(const char* APath);
=s32 save_screenshot(const char* AFormCaption, const char* AFilePath);
=s32 enable_all_graphics(const bool AEnable, const char* AExceptCaption);
=s32 get_tsmaster_version(ps32 AYear, ps32 AMonth, ps32 ADay, ps32 ABuildNumber);
=s32 ui_show_page_by_index(const s32 AIndex);
=s32 ui_show_page_by_name(const char* AName);
=s32 write_realtime_comment(const char* AName);
=s32 set_thread_priority(const s32 APriority);
=s32 get_system_var_generic(const char* ACompleteName, const s32 ACapacity, char* AValue);
=s32 set_system_var_generic(const char* ACompleteName, const char* AValue);
=s32 write_text_file_start(const char* AFileName, s32* AHandle);
=s32 write_text_file_line(const s32 AHandle, const char* ALine);
=s32 write_text_file_line_double_array(const s32 AHandle, const double* AArray, const s32 ACount);
=s32 write_text_file_line_string_array(const s32 AHandle, const char** AArray, const s32 ACount);
=s32 write_text_file_end(const s32 AHandle);
=s32 force_directory(const char* ADir);
=s32 directory_exists(const char* ADir);
=s32 open_directory_and_select_file(const char* AFileName);
=s32 mini_delay_cpu(void);
=s32 wait_system_var(const char* ACompleteName, const char* AValue, const s32 ATimeoutMs);
=s32 write_mat_file_start(const char* AFileName, s32* AHandle);
=s32 write_mat_file_variable_double(const s32 AHandle, const char* AVarName, const double AValue);
=s32 write_mat_file_variable_string(const s32 AHandle, const char* AVarName, const char* AValue);
=s32 write_mat_file_variable_double_array(const s32 AHandle, const char* AVarName, const double* AArray, const s32 ACount);
=s32 write_mat_file_end(const s32 AHandle);
=s32 read_mat_file_start(const char* AFileName, s32* AHandle);
=s32 read_mat_file_variable_count(const s32 AHandle, const char* AVarName, ps32 ACount);
=s32 read_mat_file_variable_string(const s32 AHandle, const char* AVarName, char** AValue, const s32 ACapacity);
=s32 read_mat_file_variable_double(const s32 AHandle, const char* AVarName, const double* AValue, const s32 AStartIdx, const s32 ACount);
=s32 read_mat_file_end(const s32 AHandle);
=s32 prompt_user_input_value(const char* APrompt, double* AValue);
=s32 prompt_user_input_string(const char* APrompt, char* AValue, const s32 ACapacity);
=s32 ini_create(const char* AFileName, s32* AHandle);
=s32 ini_write_int32(const s32 AHandle, const char* ASection, const char* AKey, const s32 AValue);
=s32 ini_write_int64(const s32 AHandle, const char* ASection, const char* AKey, const s64 AValue);
=s32 ini_write_bool(const s32 AHandle, const char* ASection, const char* AKey, const bool AValue);
=s32 ini_write_float(const s32 AHandle, const char* ASection, const char* AKey, const double AValue);
=s32 ini_write_string(const s32 AHandle, const char* ASection, const char* AKey, const char* AValue);
=s32 ini_read_int32(const s32 AHandle, const char* ASection, const char* AKey, const s32* AValue, const s32 ADefault);
=s32 ini_read_int64(const s32 AHandle, const char* ASection, const char* AKey, const s64* AValue, const s64 ADefault);
=s32 ini_read_bool(const s32 AHandle, const char* ASection, const char* AKey, const bool* AValue, const bool ADefault);
=s32 ini_read_float(const s32 AHandle, const char* ASection, const char* AKey, const double* AValue, const double ADefault);
=s32 ini_read_string(const s32 AHandle, const char* ASection, const char* AKey, const char* AValue, s32* ACapacity, const char* ADefault);
=s32 ini_section_exists(const s32 AHandle, const char* ASection);
=s32 ini_key_exists(const s32 AHandle, const char* ASection, const char* AKey);
=s32 ini_delete_key(const s32 AHandle, const char* ASection, const char* AKey);
=s32 ini_delete_section(const s32 AHandle, const char* ASection);
=s32 ini_close(const s32 AHandle);
=s32 make_toast_until(const char* AString, const TLogLevel ALevel, const bool* ACloseCriteria, const bool AUserCanBreak);
=s32 make_toast_with_callback(const char* AString, const TLogLevel ALevel, const TCheckResultCallback ACallback, const bool AUserCanBreak);
=s32 get_doc_path(char** AFilePath); 
=s32 get_hardware_id_string(char** AIDString);
=s32 get_hardware_id_array(pu8 AArray8B);
=s32 create_system_var(const char* ACompleteName, const TLIBSystemVarType AType, const char* ADefaultValue, const char* AComment);
=s32 delete_system_var(const char* ACompleteName);
=s32 run_form(const char* AFormCaption);
=s32 stop_form(const char* AFormCaption);
=s32 read_text_file_start(const char* AFileName, s32* AHandle);
=s32 read_text_file_line(const s32 AHandle, const s32 ACapacity, ps32 AReadCharCount, char* ALine);
=s32 read_text_file_end(const s32 AHandle);
=s32 play_sound(const bool AIsSync, const char* AWaveFileName);

[com]
=s32 transmit_can_async(const PCAN ACAN);
=s32 transmit_canfd_async(const PCANFD ACANFD);
=s32 transmit_lin_async(const PLIN ALIN);
=s32 transmit_can_sync(const PCAN ACAN, const s32 ATimeoutMS);
=s32 transmit_canfd_sync(const PCANFD ACANFD, const s32 ATimeoutMS);
=s32 transmit_lin_sync(const PLIN ALIN, const s32 ATimeoutMS);
=double get_can_signal_value(const PCANSignal ACANSignal, const pu8 AData);
=void set_can_signal_value(const PCANSignal ACANSignal, const pu8 AData, const double AValue);
=s32 enable_bus_statistics(const bool AEnable);
=s32 clear_bus_statistics(void);
=s32 get_bus_statistics(const TLIBApplicationChannelType ABusType, const s32 AIdxChn, const TLIBCANBusStatistics AIdxStat, pdouble AStat);
=s32 get_fps_can(const s32 AIdxChn, const s32 AIdentifier, ps32 AFPS);
=s32 get_fps_canfd(const s32 AIdxChn, const s32 AIdentifier, ps32 AFPS);
=s32 get_fps_lin(const s32 AIdxChn, const s32 AIdentifier, ps32 AFPS);
=s32 wait_can_message(const PCAN ATxCAN, const PCAN ARxCAN, const s32 ATimeoutMS);
=s32 wait_canfd_message(const PCANFD ATxCANFD, const PCANFD ARxCANFD, const s32 ATimeoutMS);
=s32 add_cyclic_message_can(const PCAN ACAN, const float APeriodMS);
=s32 add_cyclic_message_canfd(const PCANFD ACANFD, const float APeriodMS);
=s32 del_cyclic_message_can(const PCAN ACAN);
=s32 del_cyclic_message_canfd(const PCANFD ACANFD);
=s32 del_cyclic_messages(void);
=s32 tslog_add_online_replay_config(const char* AFileName, s32* AIndex);
=s32 tslog_set_online_replay_config(const s32 AIndex, const char* AName, const char* AFileName, const bool AAutoStart, const bool AIsRepetitiveMode, const TLIBOnlineReplayTimingMode AStartTimingMode, const s32 AStartDelayTimeMs, const bool ASendTx, const bool ASendRx, const char* AMappings);
=s32 tslog_get_online_replay_count(s32* ACount);
=s32 tslog_get_online_replay_config(const s32 AIndex, char** AName, char** AFileName, bool* AAutoStart, bool* AIsRepetitiveMode, TLIBOnlineReplayTimingMode* AStartTimingMode, s32* AStartDelayTimeMs, bool* ASendTx, bool* ASendRx, char** AMappings);
=s32 tslog_del_online_replay_config(const s32 AIndex);
=s32 tslog_del_online_replay_configs(void);
=s32 tslog_start_online_replay(const s32 AIndex);
=s32 tslog_start_online_replays(void);
=s32 tslog_pause_online_replay(const s32 AIndex);
=s32 tslog_pause_online_replays(void);
=s32 tslog_stop_online_replay(const s32 AIndex);
=s32 tslog_stop_online_replays(void);
=s32 tslog_get_online_replay_status(const s32 AIndex, TLIBOnlineReplayStatus* AStatus, float* AProgressPercent100);
=s32 can_rbs_start(void);
=s32 can_rbs_stop(void);
=s32 can_rbs_is_running(bool* AIsRunning);
=s32 can_rbs_configure(const bool AAutoStart, const bool AAutoSendOnModification, const bool AActivateNodeSimulation, const TLIBRBSInitValueOptions AInitValueOptions);
=s32 can_rbs_activate_all_networks(const bool AEnable, const bool AIncludingChildren);
=s32 can_rbs_activate_network_by_name(const bool AEnable, const char* ANetworkName, const bool AIncludingChildren);
=s32 can_rbs_activate_node_by_name(const bool AEnable, const char* ANetworkName, const char* ANodeName, const bool AIncludingChildren);
=s32 can_rbs_activate_message_by_name(const bool AEnable, const char* ANetworkName, const char* ANodeName, const char* AMsgName);
=s32 can_rbs_set_message_cycle_by_name(const s32 AIntervalMs, const char* ANetworkName, const char* ANodeName, const char* AMsgName);
=s32 can_rbs_get_signal_value_by_element(const s32 AIdxChn, const char* ANetworkName, const char* ANodeName, const char* AMsgName, const char* ASignalName, double* AValue);
=s32 can_rbs_get_signal_value_by_address(const char* ASymbolAddress, double* AValue);
=s32 can_rbs_set_signal_value_by_element(const s32 AIdxChn, const char* ANetworkName, const char* ANodeName, const char* AMsgName, const char* ASignalName, const double AValue);
=s32 can_rbs_set_signal_value_by_address(const char* ASymbolAddress, const double AValue);
=s32 tslog_blf_write_start(const char* AFileName, s32* AHandle);
=s32 tslog_blf_write_start_w_timestamp(const char* AFileName, s32* AHandle, u16* AYear, u16* AMonth, u16* ADay, u16* AHour, u16* AMinute, u16* ASecond, u16* AMilliseconds);
=s32 tslog_blf_write_set_max_count(const s32 AHandle, const u32 ACount);
=s32 tslog_blf_write_can(const s32 AHandle, const PCAN ACAN);
=s32 tslog_blf_write_can_fd(const s32 AHandle, const PCANFD ACANFD);
=s32 tslog_blf_write_lin(const s32 AHandle, const PLIN ALIN);
=s32 tslog_blf_write_realtime_comment(const s32 AHandle, const s64 ATimeUs, const char* AComment);
=s32 tslog_blf_write_end(const s32 AHandle);
=s32 tslog_blf_read_start(const char* AFileName, s32* AHandle, s32* AObjCount);
=s32 tslog_blf_read_status(const s32 AHandle, s32* AObjReadCount);
=s32 tslog_blf_read_object(const s32 AHandle, s32* AProgressedCnt, TSupportedBLFObjType* AType, PCAN ACAN, PLIN ALIN, PCANFD ACANFD);
=s32 tslog_blf_read_object_w_comment(const s32 AHandle, s32* AProgressedCnt, TSupportedBLFObjType* AType, PCAN ACAN, PLIN ALIN, PCANFD ACANFD, Prealtime_comment_t AComment);
=s32 tslog_blf_read_end(const s32 AHandle);
=s32 tslog_blf_seek_object_time(const s32 AHandle, const double AProg100, s64* ATime, s32* AProgressedCnt);
=s32 tslog_blf_to_asc(const char* ABLFFileName, const char* AASCFileName, const TProgressCallback AProgressCallback);
=s32 tslog_asc_to_blf(const char* AASCFileName, const char* ABLFFileName, const TProgressCallback AProgressCallback);
=s32 ioip_create(const u16 APortTCP, const u16 APortUDP, const TOnIoIPData AOnTCPDataEvent, const TOnIoIPData AOnUDPEvent, s32* AHandle);
=s32 ioip_delete(const s32 AHandle);
=s32 ioip_enable_tcp_server(const s32 AHandle, const bool AEnable);
=s32 ioip_enable_udp_server(const s32 AHandle, const bool AEnable);
=s32 ioip_connect_tcp_server(const s32 AHandle, const char* AIpAddress, const u16 APort);
=s32 ioip_connect_udp_server(const s32 AHandle, const char* AIpAddress, const u16 APort);
=s32 ioip_disconnect_tcp_server(const s32 AHandle);
=s32 ioip_send_buffer_tcp(const s32 AHandle, const pu8 APointer, const s32 ASize);
=s32 ioip_send_buffer_udp(const s32 AHandle, const pu8 APointer, const s32 ASize);
=s32 ioip_receive_tcp_client_response(const s32 AHandle, const s32 ATimeoutMs, const pu8 ABufferToReadTo, ps32 AActualSize);
=s32 ioip_send_tcp_server_response(const s32 AHandle, const pu8 ABufferToWriteFrom, const s32 ASize);
=s32 ioip_send_udp_broadcast(const void* AObj, const s32 AHandle, const u16 APort, const pu8 ABufferToWriteFrom, const s32 ASize);
=s32 ioip_set_udp_server_buffer_size(const void* AObj, const s32 AHandle, const s32 ASize);
=s32 ioip_receive_udp_client_response(const void* AObj, const s32 AHandle, const s32 ATimeoutMs, const pu8 ABufferToReadTo, ps32 AActualSize);
=s32 ioip_send_udp_server_response(const void* AObj, const s32 AHandle, const pu8 ABufferToWriteFrom, const s32 ASize);
=s32 sgnsrv_register_can_signal_by_msg_identifier(const s32 AIdxChn, const s32 AMsgId, const char* ASgnName, ps32 AClientId);
=s32 sgnsrv_register_lin_signal_by_msg_identifier(const s32 AIdxChn, const s32 AMsgId, const char* ASgnName, ps32 AClientId);
=s32 sgnsrv_register_can_signal_by_msg_name(const s32 AIdxChn, const char* ANetworkName, const char* AMsgName, char* ASgnName, ps32 AClientId);
=s32 sgnsrv_register_lin_signal_by_msg_name(const s32 AIdxChn, const char* ANetworkName, const char* AMsgName, char* ASgnName, ps32 AClientId);
=s32 sgnsrv_get_can_signal_phy_value_latest(const s32 AIdxChn, const s32 AClientId, pdouble AValue, ps64 ATimeUs);
=s32 sgnsrv_get_lin_signal_phy_value_latest(const s32 AIdxChn, const s32 AClientId, pdouble AValue, ps64 ATimeUs);
=s32 sgnsrv_get_can_signal_phy_value_in_msg(const s32 AIdxChn, const s32 AClientId, const PCANFD AMsg, pdouble AValue, ps64 ATimeUs);
=s32 sgnsrv_get_lin_signal_phy_value_in_msg(const s32 AIdxChn, const s32 AClientId, const PLIN AMsg, pdouble AValue, ps64 ATimeUs);

[test]
=void set_verdict_ok(const char* AMsg);
=void set_verdict_nok(const char* AMsg);
=void set_verdict_cok(const char* AMsg);
=void log_info(const char* AMsg, const TLogLevel ALevel);
=void write_result_string(const char* AName, const char* AValue, const TLogLevel ALevel);
=void write_result_value(const char* AName, const double AValue, const TLogLevel ALevel);
=void check_error_begin(void);
=s32 check_error_end(const ps32 AErrorCount);
=s32 write_result_image(const char* AName, const char* AImageFileFullPath);
=s32 retrieve_current_result_folder(char** AFolder);
=s32 check_test_terminate(void);
